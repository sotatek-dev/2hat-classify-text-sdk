/**
 * Classify text into risk scores
 * Will take text and classify it via risk  
 *
 * OpenAPI spec version: 2.0.1
 * Contact: support@twohat.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { LanguageClassifiedOutput } from '../model/languageClassifiedOutput';
import { TextClassifiedBulkOutput } from '../model/textClassifiedBulkOutput';
import { TextClassifiedOutput } from '../model/textClassifiedOutput';
import { TextInput } from '../model/textInput';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class DefaultService {

    protected basePath = 'https://virtserver.swaggerhub.com/twohat/classifyText/2.0.1';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * perform language identification
     * Given a piece of text it will analyze it to see what languages it might be.  Unlike other language identification trained on long properly formatted text (a relatively easy task) this one is trained on short text with frequent misspellings and internet slang  NOTE This item is a POST for PII reasons to prevent caching of GET requests 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public classifyLanguage(observe?: 'body', reportProgress?: boolean): Observable<LanguageClassifiedOutput>;
    public classifyLanguage(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<LanguageClassifiedOutput>>;
    public classifyLanguage(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<LanguageClassifiedOutput>>;
    public classifyLanguage(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.request<LanguageClassifiedOutput>('post',`${this.basePath}/classify/language`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * classify text
     * 
     * @param body 
     * @param extended If extended&#x3D;true in the request it will output the longer details of all things it considered.  This is quite a bit more costly in latency and CPU to run so we advise to only call it when needed.  As such it will be billed as 2 requests instead of one. 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public classifyText(body?: TextInput, extended?: boolean, observe?: 'body', reportProgress?: boolean): Observable<TextClassifiedOutput>;
    public classifyText(body?: TextInput, extended?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TextClassifiedOutput>>;
    public classifyText(body?: TextInput, extended?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TextClassifiedOutput>>;
    public classifyText(body?: TextInput, extended?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (extended !== undefined && extended !== null) {
            queryParameters = queryParameters.set('extended', <any>extended);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<TextClassifiedOutput>('post',`${this.basePath}/classify/text`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * classify text
     * Same as /classify/text but does so in bulk4
     * @param body 
     * @param extended If extended&#x3D;true in the request it will output the longer details of all things it considered.  This is quite a bit more costly in latency and CPU to run so we advise to only call it when needed.  As such it will be billed as 2 requests instead of one. 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public classifyTextBulk(body?: Array<TextInput>, extended?: boolean, observe?: 'body', reportProgress?: boolean): Observable<TextClassifiedBulkOutput>;
    public classifyTextBulk(body?: Array<TextInput>, extended?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TextClassifiedBulkOutput>>;
    public classifyTextBulk(body?: Array<TextInput>, extended?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TextClassifiedBulkOutput>>;
    public classifyTextBulk(body?: Array<TextInput>, extended?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (extended !== undefined && extended !== null) {
            queryParameters = queryParameters.set('extended', <any>extended);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<TextClassifiedBulkOutput>('post',`${this.basePath}/classify/textBulk`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Is the service running
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public statusGet(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public statusGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public statusGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public statusGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('get',`${this.basePath}/status`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
